#include <iostream>
#include <string>

using namespace std;


/*
 * 다형성 : 여러개의 서로 다른 객체가 동일한 기능을 서로 다른방법으로 처리할 수 있는 기능을 의미
 * 자식클래스 오버라이딩 문제점
 *  - 포인터변수로 ㅇ접근할 시 변수타입이 아닌 포인터 타입을 기준으로 함수를 호출함.
 * 가상함수 (virtual function)
 * - 자식클래스에서 재정의할 수 있는 멤버함수.
 * - virtual 키워드로 사용.
 * - c++ 컴파일러는 가상함수테이블을 이용해 가상함수를 다룬다.
 *   각각ㄱ의 객체마다 가상함수테이블을 가리키는 포인터를 저장하기 위한 멤버를 하나씩 저장한다.
 *   가상함수테이블에는 특정한 클래스의 객체들을 위해 선언된 가상함수들의 주소가 저장된다.
 *   따라서 가상함수를 호출하면 c++프로그램은 가상함수테이블에 접근하여 자신이 필요한 함수의 주소를 
 *   찾아 호출하게 된다.
 *   이러한 과정은 리소스를 소모하는 동적바인딩이 일어나므로, 기본적으로 정적바인딩을 채택한다.
 *
 * 동적바인딩
 * - c++는 특정 함수를 호출할 때 해당 함수의 루틴이 기록된 메모리 주소를 알아야 함. 소스코드에서 실제
 *   로 함수가 정의된 메모리 공간을 찾기위해 바인딩 과정이 필요하다.
 * - 일반적으로 함수호출 시 컴파일할 때 고정된 메모리주소를 사용(정적바인딩)하는데, 
 *   가상함수는 프로그램이 실행될 때 객체를 결정하므로 (컴파일 할 때 객체를 특정하지 못함) 
 *   런타임 시 동적바인딩으로 주소를 찾음.
 *
 * 가상클래스의 소멸자
 * - c++에서는 상속관계가 있으므면서 동시에 메모리해제를 해야 하는 경우에 반드시 부모 클래스의
 *   소멸자를 가상함수로 선언해야 한다. 부모 포인터로 객체를 삭제하면 부모클래스의 소멸자가
 *   호출되기 때문이다.
 *   만약 다형성을 이용할 때 소멸자를 가상함수로 선언하지 않으면 자식클래스의 소멸자는 호출되지 않고
 *   부모클래스의 소멸자만 호출되므로, 자식은 정상적으로 해제되지 않음.
 *
 * 순수가상함수
 * - c++의 가상함수는 기본적으로 반드시 재정의 할 필요는 없으나 순수가상함수는 그래야 한다.
 *   =0 키워드로 사용가능
 *   순수가상함수를 정의하면, 부모클래스는 abstract class가 되어 객체선언 (A a;)이 안됨..
 */
class A
{
	public:
		//void show() { cout << "A class" << endl; }
		//virtual void show2() { cout << "A class" << endl; }
		virtual void show3() = 0;
};

class B : public A
{
	//void show() { cout << "B class" << endl; }
	///virtual void show2() { cout << "B class" << endl; }
	virtual void show3() { cout << "A class" << endl; }
};

int	main(void)
{
	A* p;
	//A a;
	B b;
	//p = &a;
	//p->show();
	//p->show2();
	p = &b; // A클래스의 show 함수를 호출함.
	//p->show();
	//p->show2();

}
